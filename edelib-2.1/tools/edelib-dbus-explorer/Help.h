#ifndef __EDELIB_DBUS_EXPLORER_HELP_H__
#define __EDELIB_DBUS_EXPLORER_HELP_H__

/* Autogenerated from edelib-dbus-explorer.txt. Edit that file, not this one. */
static const char help_content[] =
    "Introduction\n"
    "============\n"
    "\n"
    "edelib-dbus-explorer is handy tool for exploring, inspecting and calling DBus\n"
    "services, their methods, signals and properties. Before you start using it, make\n"
    "sure to familiarize yourself with DBus (http://www.freedesktop.org/wiki/Software/dbus)\n"
    "at least on basic level.\n"
    "\n"
    "To start using it, first connect session or service bus. To do so, from the menu choose\n"
    "File -> Connect To -> (Session Bus | Service Bus), and you will be shown with all\n"
    "available services on given connection. After selecting service, you will get service\n"
    "objects and interfaces with methods.\n"
    "\n"
    "Editor and language basics\n"
    "==========================\n"
    "\n"
    "The text you are reading now is in so called 'script editor'. This is place where you can\n"
    "write and evaluate Scheme code; by simply pointing cursor to open or closed parenthesis, you\n"
    "will get highlighted region. Pressing SHIFT-Enter will evaluate it and print the result if\n"
    "is possible. To evaluate and force print any value, you can use ALT-Enter.\n"
    "\n"
    "To see it in action, select below example and press ALT-Enter:\n"
    "\n"
    " (: 1 + 2)\n"
    "\n"
    "or maybe:\n"
    "\n"
    " (println \"Hello world\")\n"
    "\n"
    "you will see results immediately.\n"
    "\n"
    "Many of Scheme functions are self-documentable and to see it for below example, press\n"
    "SHIFT-Enter.\n"
    "\n"
    " (doc 'println)\n"
    "\n"
    "Interacting with DBus\n"
    "=====================\n"
    "\n"
    "edelib-dbus-explorer comes with almost complete Scheme binding for DBus. Returned values\n"
    "from DBus will be converted to Scheme objects and sent arguments will be used from\n"
    "Scheme objects, with additional type hints.\n"
    "\n"
    "Two main functions are provided, 'dbus-signal' and 'dbus-call' for invoking DBus signals\n"
    "and methods respectively.\n"
    "\n"
    "dbus-signal\n"
    "-----------\n"
    "\n"
    "The prototype for this call looks like:\n"
    "\n"
    "  (dbus-signal *object-path* *interface* *signal* [arguments])\n"
    "\n"
    "*object-path* is DBus object path in Scheme string form. Valid object paths are, e.g.\n"
    "\"/org/freedesktop/DBus\" or \"/foo\" or \"/\". Invalid object paths are \"/org/\", \"baz\" or\n"
    "anything else containing non-ascii characters without backslash.\n"
    "\n"
    "If you set invalid object path, you will get error and signal will not be sent.\n"
    "\n"
    "*interface* is interface name for given service. Unless interface does not exists, signal\n"
    "will not be sent and the error will be reported.\n"
    "\n"
    "*signal* is valid signal name for this service and interface.\n"
    "\n"
    "If [arguments] are provided, the signal will be sent with them. Check bellow about argument\n"
    "types to see what can be sent and in which form.\n"
    "\n"
    "This function will return #t if signal was sent to bus without problems or #f if something\n"
    "fails in the mean time.\n"
    "\n"
    "dbus-call\n"
    "---------\n"
    "\n"
    "The prototype for this call looks like:\n"
    "\n"
    "  (dbus-call *service* *object-path* *interface* *method* [arguments])\n"
    "\n"
    "*service* is known DBus service, since DBus method calls can be sent to any existing service\n"
    "on connected bus. The rest of arguments are the same as for 'dbus-signal'.\n"
    "\n"
    "Contrary to 'dbus-signal', 'dbus-call' can return other values than #t or #f. As noted at the\n"
    "beginning, those values will be converted to Scheme objects and it will be done according to\n"
    "this table:\n"
    "\n"
    "  DBUS_TYPE_BYTE         integer (1 or 0)\n"
    "  DBUS_TYPE_BOOL         integer (1 or 0)\n"
    "  DBUS_TYPE_INT16        integer\n"
    "  DBUS_TYPE_UINT16       integer\n"
    "  DBUS_TYPE_INT32        integer\n"
    "  DBUS_TYPE_UINT32       integer\n"
    "  DBUS_TYPE_INT64        integer\n"
    "  DBUS_TYPE_UINT64       integer\n"
    "  DBUS_TYPE_DOUBLE       double\n"
    "  DBUS_TYPE_STRING       string\n"
    "  DBUS_TYPE_OBJECT_PATH  string\n"
    "  DBUS_TYPE_ARRAY        vector\n"
    "  DBUS_TYPE_STRUCT       list\n"
    "  DBUS_TYPE_VARIANT      any scheme object\n"
    "  DBUS_TYPE_DICT         list of lists, e.g. ((key value) (key value) ...)\n"
    "\n"
    "Argument types\n"
    "--------------\n"
    "\n"
    "Because DBus have many similar argument types (which are the same from Scheme point of view),\n"
    "explicit typing of arguments is needed, so edelib-dbus-explorer knows how to construct DBus message.\n"
    "For example, Scheme knows about integer to represent general number(s), but DBus have int16, int32 and\n"
    "so on.\n"
    "\n"
    "Here is example how to call 'DemoMember' with string argument:\n"
    "\n"
    "  (dbus-call \"my.service\" \"/my/service\" \"my.service.Interface\" \"DemoMember\" :string \"String argument\")\n"
    "\n"
    "This is the table of types, converted to corresponding DBus type and appropriate Scheme type:\n"
    "\n"
    "  :byte         DBUS_TYPE_BYTE          integer (1 or 0)\n"
    "  :bool         DBUS_TYPE_BOOL          integer (1 or 0)\n"
    "  :int16        DBUS_TYPE_INT16         integer\n"
    "  :uint16       DBUS_TYPE_UINT16        integer\n"
    "  :int32        DBUS_TYPE_INT32         integer\n"
    "  :uint32       DBUS_TYPE_UINT32        integer\n"
    "  :int64        DBUS_TYPE_INT64         integer\n"
    "  :uint64       DBUS_TYPE_UINT64        integer\n"
    "  :double       DBUS_TYPE_DOUBLE        double \n"
    "  :string       DBUS_TYPE_STRING        string\n"
    "  :object-path  DBUS_TYPE_OBJECT_PATH   string\n"
    "  :array        DBUS_TYPE_ARRAY         list\n"
    "  :struct       DBUS_TYPE_STRUCT        list\n"
    "  :variant      DBUS_TYPE_VARIANT       any scheme object\n"
    "  :dict         DBUS_TYPE_DICT          list of lists, e.g. ((key value) (key value) ...)\n"
    "\n"
    "Note however how array, list and dictionary entries (keys and values) must also have types. To see all\n"
    "above in action, here are few examples with their descriptions:\n"
    "\n"
    "* call service with string and int32 arguments \n"
    "\n"
    "  (dbus-call \"my.service\" \"/my/service\" \"my.service.Interface\" \"DemoMember\"\n"
    "             :string \"my string\"\n"
    "             :int32  4)\n"
    "\n"
    "* call service with array of booleans\n"
    "\n"
    "  (dbus-call \"my.service\" \"/my/service\" \"my.service.Interface\" \"DemoMember\"\n"
    "             :array '(:bool 1 :bool 0 :bool 1 :bool 1))\n"
    "\n"
    "* call service with dictionary\n"
    "\n"
    "  (dbus-call \"my.service\" \"/my/service\" \"my.service.Interface\" \"DemoMember\"\n"
    "             :dict '((:string \"key\"  :int32 1)\n"
    "                     (:string \"key2\" :int32 3)))\n"
    "\n"
    "Generating calls\n"
    "================\n"
    "\n"
    "Since writing DBus calls, especially with complex arguments can be quite cumbersome, edelib-dbus-explorer\n"
    "can generate DBus call for you: just select desired method, hit right mouse click and choose\n"
    "'Send to editor'; the function call with all needed arguments (including correct service name, object path\n"
    "and etc.) will be written in script editor.\n"
    "\n"
    "The written call will also contain 'REPLACE_ME' strings: these you must replace with desired values that\n"
    "matches given type. You can jump from those unreplaced values with Tab-SHIFT shortcut.\n"
;
#endif
